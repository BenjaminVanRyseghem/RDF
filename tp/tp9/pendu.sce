                ///////////////                // FUNCTIONS //                ///////////////// retourne une matrice de 283 colonnes et 35 lignes contenant // pour chaque colonne un 1 ou un 0 si il contient la lettre correspondant à // l'indice (a à pour indice 10)function mat = presentLettersIn(noms)    n = size(noms,1);    mat = zeros(35,n);    for i = 1 : n        c = str2code(noms(i));        mat(c,i) = 1;    endendfunctionfunction h = getNumberOfLetters(noms)    // on créer une colonne de 283 afin de faire une multiplication    // entre cette colonne et la matrice de 1 et 0 retournée par presentLettersIn    // afin de récupérer une seul colonne de 35 contenant pour chaque element    // la somme des éléments de sa ligne.    one = ones(size(noms,1),1);    m = presentLettersIn(noms)    h = m * one;endfunctionfunction letter = mostPresentLettersIn(noms)    h = getNumberOfLetters(noms);    // On récupère l'indice de la lettre la plus présente    [value, mostPresentLetterCode] = max(h);    // on transforme l'indice en lettre    letter = code2str(mostPresentLetterCode);endfunctionfunction resultat = entropie(noms, n)    h = getNumberOfLetters(noms);    resultat = - log((h./n).^(h./n)) - log((1 - h./n).^(1 - h./n))endfunction                ////////////////////                // FUNCTIONS PROF //                ////////////////////function [A,B,i]=partage(I)    // only relevant words in rel    rel=mat(:,I);    nrel=size(rel,"c");    hrel=zeros(1,35);    for k=1:35        hrel(k)=sum(rel(k,:));    end;    entropierel = -log((hrel./nrel).^(hrel./nrel)) -log((1-hrel./nrel).^(1-hrel./nrel));    [m,i]=max(entropierel);    // incremental build of A and B by append boolean values on the right side    A=[];    for k=1:n        A = [A,I(k) & (mat(i,k) == 1)];    end    B=[];    for k=1:n        B = [B,I(k) & (mat(i,k) == 0)];    endendfunctionfunction joue()    printf("\nChoisissez le nom d''un animal...\n\n");    n = size(mat,'c')    I = ([1:n]>0)    while sum(I)>1 do        [A,B,i]=partage(I)        printf("Ce mot contient-il la lettre %c ? [o/n] \n",code2str(i))        c = scanf("%s")        if c=='o' then I=A, else I=B, end    end    printf("L''animal est un(e) %s\n\n",noms(I))endfunction// fonction modifié pour les questionsfunction [nbQuestion, maxim] = arbre(I,str,currentDeepth,maxDeepth)    if (sum(I)>1) then        currentDeepth = currentDeepth +1;        [A,B,i] = partage(I);                [nbQuestion1, max1] = arbre(A,str+'| ',currentDeepth,maxDeepth);                printf("%s%c (%i,%i)\n",str,code2str(i),sum(A),sum(B));                [nbQuestion2, max2] = arbre(B,str+'| ',currentDeepth,maxDeepth);                maxim = 1 + max(max1,max2);        nbQuestion = nbQuestion1 + nbQuestion2;    else        if currentDeepth == maxDeepth then            global deepestElements;            deepestElements = [deepestElements noms(I)];        end                nbQuestion = currentDeepth;                printf("%s -> %s\n",str,noms(I));        maxim = 0;    endendfunction                ///////////////////                //   MON CODE    //                ///////////////////funcprot(0);warning('off');// Chargement de la base de noms d'animauxexec("rdfAnimaux.txt");// on met dans mat une matrice de // mat = presentLettersIn(noms);// on récupère la lettre la plus présente dans tous les mots//letter = mostPresentLettersIn(noms) // h = getNumberOfLetters(noms);// calcule de l'entropie// entrop = entropie(noms)                ///////////////////                //   CODE PROF   //                ///////////////////// JOUE//mat=zeros(35,n);//for i=1:n//    c = str2code(noms(i));//    mat(c,i) = 1;//end//joue()// TEST AFFICHAGE DE TAILLE PARTAGE SUCCESSIFn// I=([1:n]>0);// [A,B,i]=partage(I);code2str(i),sum(A),sum(B)// [C,D,j]=partage(A);code2str(j),sum(C),sum(D)// [E,F,k]=partage(B);code2str(k),sum(E),sum(F)// AFFICHAGE ARBREn = size(noms,1);I=([1:n]>0);global deepestElements;deepestElements = [];global nombre;[nbQuestion, maximum] = arbre(I,' ',0,10);nbQuestion / n